[原文github地址](https://github.com/jincheng9/practical-go-cn)
 | [原文文档地址](https://dave.cheney.net/practical-go/presentations/qcon-china.html)
 | [中文翻译地址](https://github.com/llitfkitfk/go-best-practice)

- [1.指导原则](#1)
  - [1.1 简单性](#1.1)
  - [1.2 可读性](#1.2)
  - [1.3 生产力](#1.3)

- [2.标识符](#2)
    - [2.1 选择标识符是为了清晰，而不是简洁](#)2.1
    - [2.2 标识符长度](#2.2)
    - [2.3 不要用变量类型命名变量](#2.3)
    - [2.4 使用一致的命名风格](#2.4)
    - [2.5 使用一致的声明样式](#2.5)
    - [2.6 成为团队的合作者](#2.6)
- [3.注释](#3)
  - [3.1 关于变量和常量的注释应描述其内容而非其目的](#3.1)
  - [3.2 公共符号始终要注释](#3.2)
- [4.包的设计](#4)
  - [4.1 一个好的包从它的名字开始](#4.1)
  - [4.2 避免使用类似 `base`、` common`或 `util`的包名称](#4.2)
  - [4.3 尽早 `return`而不是深度嵌套](#4.3)
  - [4.4 让零值更有用](#4.4)
  - [4.5 避免包级别状态](#4.5)
- [5.项目结构](#5)
  - [5.1 考虑更少，更大的包](#5.1)
  - [5.2 保持 main包内容尽可能的少](#5.2)
- [6.API 设计](#6)
  - [6.1 设计难以被误用的 API](#6.1)
  - [6.2 为其默认用例设计 API](#6.2)
  - [6.3 让函数定义它们所需的行为](#6.3)
- [7.错误处理](#7)
  - [7.1 通过消除错误来消除错误处理](#7.1)
  - [7.2 错误只处理一次](#7.2)
- [8.并发](#8)
  - [8.1 保持自己忙碌或做自己的工作](#8.1)
  - [8.2 将并发性留给调用者](#8.2)
  - [8.3 永远不要启动一个停止不了的 `goroutine`](#8.3)

    

# <span id="1">1. 指导原则</span>
性能和并发是重要的属性，但不如简单性，可读性和生产力那么重要。

## <span id="1.1">1.1 简单性</span>
**简单性**是Go语言的最高目标。

**复杂性**：你害怕做出改变，因为你担心它会破坏程序的另一部分；你不理解的部分，不知道如何修复。

## <span id="1.2">1.2 可读性</span>
程序应该被写来**让人们阅读并理解**，只是顺便为了让机器执行。

代码的读取次数比写入次数多。一段代码在其生命周期内会被读取数百次，甚至数千次。
可读性是能够理解程序正在做什么的关键。

可读 => 易于理解（自己和他人） => 可维护

## <span id="1.3">1.3 生产力</span>

# <span id="2">2. 标识符</span>
标识符：变量名、函数名、方法名、类型名、包名等。

## <span id="2.1">2.1 选择标识符是为了清晰，而不是简洁</span>

```text
Obvious code is important. What you can do in one line you should do in three.
(清晰的代码很重要。在一行可以做的你应当分三行做。)
— Ukiah Smith
```

清晰的关键是在 Go 语言程序中我们选择的标识名称。让我们谈一谈所谓好的名字：

 - **好的名字很简洁。** 好的名字不一定是最短的名字，但好的名字不会浪费在无关的东西上。好名字具有高的信噪比。

 - **好的名字是描述性的。** 好的名字会描述变量或常量的应用，而不是它们的内容。好的名字应该描述函数的结果或方法的行为，而不是它们的操作。好的名字应该描述包的目的而非它的内容。描述东西越准确的名字就越好。

 - **好的名字应该是可预测的。** 你能够从名字中推断出使用方式。~ 这是选择描述性名称的功能，但它也遵循传统。~ 这是 Go 程序员在谈到习惯用语时所谈论的内容。

## <span id="2.2">2.2 标识符长度</span>
名字的声明和他的使用之间的距离越大，名字应该越长。
由此我们可以得出一些指导方针：

 - **短变量名称**在声明和上次使用之间的距离很短时效果很好。

 - **长变量名称**需要证明自己的合理性; 名称越长，需要提供的价值越高。冗长的名称与页面上的重量相比，信号量较小。

 - 请勿在变量名称中包含**类型名称**。

 - **常量**应该描述它们持有的值，而不是该如何使用。

 - 对于**循环和分支**使用单字母变量，**参数和返回值**使用单个字，**函数和包级别**声明使用多个单词

 - **方法、接口和包**使用单个词。

 - 请记住，**包的名称**是调用者用来引用名称的一部分，因此要好好利用这一点。

```text
贴士: 
与使用段落分解文档的方式一样用空行来分解函数。 在 AverageAge中，按顺序共有三个操作。 第一个是前提条件，检查 people是否为空，
第二个是 sum和 count的累积，最后是平均值的计算。
```
### 2.2.1 上下文是关键
关于命名的大多数建议都是需要考虑上下文的，这是一个原则，而不是一个规则。

```text
贴士: 在同一声明中长和短形式的参数不能混搭。
```

## <span id="2.3">2.3 不要用变量类型命名你的变量</span>
变量的名称应描述其内容，而不是内容的类型。

```go
    var usersMap map[string] *User
```

这个声明有什么好处？ 我们可以看到它是一个 map，它与 *User类型有关。 但是 usersMap是一个 map，
而 Go 语言是一种静态类型的语言，如果没有定义变量, 不会让我们意外地使用到它， 因此 Map后缀是多余的。
Map后缀并没有提高代码的清晰度，它只是增加了要输入的额外样板代码。

```text
贴士: 
如果 users的描述性都不够用，那么 usersMap也不会。
```

此建议也适用于函数参数。

```text
贴士:
不要让包名窃取好的变量名。
导入标识符的名称包括其包名称。 例如， context包中的 Context类型将被称为 context.Context。 这使得无法将 context用作包中的变量或类型。

func WriteLog(context context.Context, message string)
上面的栗子将会编译出错。 这就是为什么 context.Context类型的通常的本地声明是 ctx。 例如。
func WriteLog(ctx context.Context, message string)
```
## <span id="2.4">2.4 使用一致的命名方式</span>
一个好的名字应该是可预测的。在第一次遇到该名字时读者就能够理解名字的使用。当他们遇到
常见的名字时，他们应该能够认为自从他们上次看到它以来它没有改变意义。

```text
贴士: 
如果你发现自己有如此多的嵌套循环， i， j和 k变量都无法满足时，这个时候可能就是需要将函数分解成更小的函数。
```
## <span id="2.5">2.5 使用一致的声明样式</span>

Go至少有五种不同的方式来声明变量。
 - `var x int = 1`
 - `var x = 1`
 - `var x int; x = 1`
 - `var x = int(1)`
 - `x := 1`

尽可能遵守以下规范：
 - 声明变量但没有初始化时，请使用 `var`。 当声明变量稍后将在函数中初始化时，请使用 `var`关键字。
 - 在声明和初始化时，使用 `:=`。 在同时声明和初始化变量时，也就是说我们不会将变量初始化为零值，我建议使用短变量声明。 这使得读者清楚地知道 `:=`左侧的变量是初始化过的。

## <span id="2.6">2.6 成为团队合作者</span>
遵循项目本身的代码风格比遵循个人偏好在代码维护方面更有价值。

# <span id="3">3. 注释</span>
注释对 Go 语言程序的可读性非常重要。 注释应该做的三件事中的一件：

1. 注释应该解释其作用。
2. 注释应该解释其如何做的。
3. 注释应该解释其原因。

第一种形式是公共符号注释的理想选择：
```text
// Open opens the named file for reading.
// If successful, methods on the returned file can be used for reading.
```
第二种形式非常适合在方法中注释：
```go
// queue all dependant actions
var results []chan error
for _, dep := range a.Deps {
        results = append(results, execute(seen, dep))
}
```
第三种形式是独一无二的，因为它不会取代前两种形式，但与此同时它并不能代替前两种形式。 此形式的注解用以解释代码的外部因素。 这些因素脱离上下文后通常很难理解，此注释的为了提供这种上下文。
```go
return &v2.Cluster_CommonLbConfig{
	// Disable HealthyPanicThreshold
        HealthyPanicThreshold: &envoy_type.Percent{
        	Value: 0,
        },
}
```
在此示例中，无法清楚地明白 HealthyPanicThreshold 设置为零百分比的效果。 需要注释 0 值将禁用 panic 阈值。

# <span id="3.1">3.1 关于变量和常量的注释应描述其内容而非其目的</span>







