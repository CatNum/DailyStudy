
## 一、内存对齐

## 1、参考文章


协程跟线程是有区别的，**线程由 CPU 调度是抢占式的**，**协程由用户态调度是协作式的**，一个协程让出 CPU 后，才执行下一个协程。

将 P 个数设置为 GOMAXPROCS 的值，即程序能够同时运行的最大处理器数

Goroutine 特点：

- 占用内存更小（几 kb）
- 调度更灵活 (runtime 调度)

在 Go 中，**线程是运行 goroutine 的实体**，调度器的功能是把可运行的 goroutine 分配到工作线程上。

![img.png](picture/2）1-1.png)

- **全局队列（Global Queue）**：存放等待运行的 G。
- **P 的本地队列**：同全局队列类似，存放的也是等待运行的 G，存的数量有限，不超过 256 个。新建 G’时，G’优先加入到 P 的本地队列，如果队列满了，则会把本地队列中一半的 G 移动到全局队列。
- **P 列表**：所有的 P 都在程序启动时创建，并保存在数组中，最多有 GOMAXPROCS(可配置) 个。
- **M**：线程想运行任务就得获取 P，从 P 的本地队列获取 G，P 队列为空时，优先从全局获取，获取不到则从其他 P 偷。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。

调度器的设计策略：
- **尽可能复用线程 M**，避免频繁的线程创建和销毁；
- 利用**多核并行能力**，限制同时运行（不包含阻塞）的 M 线程数 等于 CPU 的核心数目；
- **Work Stealing 任务窃取机制**，当本线程无可运行的 G 时，优先从全局获取，获取不到则从其他 P 偷，而不是销毁线程；
- **Hand Off 交接机制**，为了提高效率，M 阻塞时，会将 M 上 P 的运行队列交给其他 M 执行；
- **基于协作的抢占机制**，为了保证公平性和防止 Goroutine 饥饿问题，Go 程序会保证每个 G 运行 10ms 就让出 M，交给其他 G 去执行，这个 G 运行 10ms 就让出 M 的机制，是由单独的系统监控线程通过 retake() 函数给当前的 G 发送抢占信号实现的，如果所在的 P 没有陷入系统调用且没有满，让出的 G 优先进入本地 P 队列，否则进入全局队列；；
- **基于信号的真抢占机制**，尽管基于协作的抢占机制能够缓解长时间 GC 导致整个程序无法工作和大多数 Goroutine 饥饿问题，但是还是有部分情况下，Go调度器有无法被抢占的情况，例如，for 循环或者垃圾回收长时间占用线程，为了解决这些问题， Go1.14 引入了基于信号的抢占式调度机制，能够解决 GC 垃圾回收和栈扫描时存在的问题；


为什么不直接将本地队列放在 M 上、而是要放在 P 上呢？ 

这是因为当一个线程 M 阻塞（可能执行系统调用或 IO请求）的时候，可以将和它绑定的 P 上的 G 转移到其他线程 M 去执行，如果直接把可运行 G 组成的本地队列绑定到 M，则万一当前 M 阻塞，它拥有的 G 就不能给到其他 M 去执行了。



> 参考链接：
>
> [[Golang三关-典藏版] Golang 调度器 GMP 原理与调度全分析](https://learnku.com/articles/41728 "[Golang三关-典藏版] Golang 调度器 GMP 原理与调度全分析")
>
> [深入分析Go1.18 GMP调度器底层原理](https://zhuanlan.zhihu.com/p/586236582 "深入分析Go1.18 GMP调度器底层原理")
> 
> [Go底层原理：一起来唠唠GMP调度（一）](https://blog.csdn.net/weixin_46618592/article/details/129333252 "Go底层原理：一起来唠唠GMP调度（一）")