## 一、MySQL 性能调优之SQL优化

### 1.1 前置知识

**无论什么关系型数据库，本质上SQL的语法都是相同的，因为它们都实现了相同的SQL标准，不同数据库之间仅支持的特性不同而已。**

SQL 优化可以看作是一个更大的主题“数据库优化”下的一个子议题。数据库优化主要包含以下内容：
- 硬件资源优化：换更大更强的机器。
- 操作系统优化：调整操作系统的某些设置。
- 服务器/引擎优化：也就是针对数据库软件本体进行优化，比如说调整事务隔离级别。在 MySQL 里面还可以针对不同的引擎做优化，比如说调整 InnoDB 引擎的日志刷盘时机。
- SQL 优化：针对的就是 SQL 本身了。

![img.png](picture/7-3）1.1-1.png)


SQL 优化就是为了达到两个目标：
- **减少磁盘 IO，** 这个又可以说是尽量**避免全表扫描、尽量使用索引以及尽量使用覆盖索引**。
- **减少内存 CPU 消耗，** 这一部分主要是**尽可能减少排序、分组、去重之类**的操作。

一般优化 SQL 都是在 **EXPLAIN 查看执行计划、尝试优化**两个步骤之间循环往复，直到发现 SQL 性能达标。

### 1.2 编写 SQL 的基本功

面对复杂的 SQL 语句，我们可以**拆解业务需求，先以定值推导 SQL。**

- 拆分业务需求：面对一个较为复杂或较难实现的业务需求时，就可以**按照需求进行逐步拆分，化繁为简后逐步实现**。其实对于这个道理很多人都懂，但往往在实际编写 SQL 时却想着一步到位，这也是我接触很多程序员后发现的问题：经验尚未丰富的开发，面对一个需求时通常都想着从头写到尾。但这样写就很容易卡壳，对于简单的业务需求可以这样做，但面对复杂业务时一定要先拆解需求后再逐步实现。
- 先以定值推导 SQL：这是啥意思呢？因为有些情况下，一个查询条件会依赖于另一条 SQL 的执行结果来决定，很多人在这种情况下会直接组合起来一起写，但这会导致编写 SQL 的复杂度再次提升，因此在这种情况下，可以**先用指定值作为条件去查询，例如 xx = "xxx"，后面等整体 SQL 完成后，再套入 SQL。**

**扎实的基础理论知识，会决定一个人水平飞得有多高，但能够将相应的理论用于实践，这才能真正体现出一个人的水平有多牛。**

### 1.2.1 SQL 优化的小技巧

如何让自己的 SQL 又快又好呢？答案其实非常简单，**减小查询的数据量、提升 SQL 的索引命中率即可**，接着先来说说撰写 SQL 时的一些注意点。

- 查询时尽量不使用 *。
  - 分析成本变高。写 * ，分析器需要去分析表上有哪些字段，明确字段，分析器就不需要这一步。
  - 网络开销变大。线上环境程序和数据库不在一个机器，返回所有字段，网络传输的数据会增多。
  - 内存占用变高。查询一条数据时，需要将结果集放入 Buffer Pool 中，字段变多，结果集也变大，占用内存比较多。
  - 维护性变差。
  - 基于非主键字段查询可能会产生**回表现象**。
- 连表查询时尽量不要关联太多表。
- 多表查询时一定要以小驱大。写 SQL 时最好自己去选择驱动表，小表放前，大表放后！
- 尽量使用索引，避免索引失效场景。
- 避免频繁创建、销毁临时表
- 尽量将大事务拆分为小事务执行：如果当一个事务比较大时，会导致一部分数据的锁定周期较长，在高并发情况下会引起大量事务出现阻塞，从而最终拖垮整个 MySQL 系统。
- 从业务设计层面减少大量数据返回的情况：如果项目中存在这类业务，一定要记住拆分掉它，比如分批返回给客户端。
- 尽量避免深分页的情况出现：比如 `select xx,xx,xx from yyy limit 100000,10;`
- SQL务必要写完整，不要使用缩写法。

可以把 SQL 当成一个链式处理器，每一次新的子查询、关联查询、条件处理....等情况时，都可以看成一道道的工序，我们在写 SQL 时要注意的是：**在下一道工序开始前尽量缩小数据量，为下一道工序尽可能提供更加精准的数据。**

### 1.3 选择索引列

- **外键**，一般都会用于关联、过滤数据，所以正常来说都会为表的外键创建索引。
- **频繁出现在 WHERE 中的列**，主要是为了避免全表扫描。
- **频繁出现在 ORDER BY 的列**，这是为了**避免**数据库在查询出来结果之后**再次排序**。
- 频繁出现在关联查询的关联条件中的列。不过一般我们都不建议使用关联查询，所以几乎可以忽略这个。
- **区分度很高的列**。比如每一行的数据都不同的列，并且在**创建组合索引的时候，区分度很高的列应该尽可能放到左边。**

### 1.4 大表表定义变更

修改索引或者说表定义变更的**核心问题是数据库会加表锁，直到修改完成（元数据锁）**。

可见大表表结构变更是一件很麻烦的事情，一般可以考虑的方案有 3 种：
- **停机变更**，就是把业务停下来，然后更新表结构。如果做得更加精细一点，那么就可以说只把和这个表有关的功能下线，但不需要将整个服务或者系统下线。
- **在业务低谷变更**，比停机更新好一点，但是业务依旧受到了影响。而且万一你以为在低谷能完成变更，结果并没有，那么你就面临着业务在高峰期也不能用的问题。
- **创建新表**，这是不停机又不想业务受到影响的方案。具体来说就是创建一张新表，这张新表就是你准备用的新的表定义。然后将旧表的数据迁移过去，我们在后面会专门讨论数据迁移方案。

### 1.5 面试准备

你需要准备很多个 SQL 优化的案例，这些案例可以体现你对 SQL 和数据库底层不同技术点的理解。为此你需要收集和整理好一些信息：
- 你维护的业务的所有表结构定义（包含索引定义），每张表上执行**最频繁的三个 SQL是否用到了索引**。
- 公司内部曾经或者已有的慢 SQL是怎么发现、分析和优化的。然后要**记住 SQL 优化前后的执行时间，以凸显优化的效果**。
- 每一个 SQL 优化案例你都要考虑清楚面试官如果要深挖，那么会朝着什么方向深挖。

当面试官问到这些问题的时候，你都可以将话题引导到 SQL 优化中。

- 你是否做过性能优化？
- 接口的响应时间是多少？有没有优化的空间？
- 你是否了解索引？是否用过索引？

还有一种比较罕见的面试方式是面试官会要求你手写 SQL。手写之后，面试官会进一步考察在特定的一些场景下，你的 SQL 是否会有问题。
**记住，但凡让你手写 SQL 的题目，你都要谨慎考虑 SQL 有没有改进的空间。**

### 1.6 优化案例

#### 1.6.1 覆盖索引

覆盖索引是最为常见的优化。比如说你执行最多的 SELECT 语句是 SELECT A, B, C 三个列，而且 WHERE 里面也只有这三个列的条件，那么就可以考虑直接创建一个 <A, B, C> 组合索引。

正常来说，**对于非常高频的 SQL，都要考虑避免回表**，那么设计一个合适的覆盖索引就非常重要了。

#### 1.6.2 优化 ORDER BY

**关键词是将排序列加入索引。**

我在公司优化过一个 SQL，这个 SQL 非常简单，就是将某个人的数据搜索出来，然后按照数据的最后更新时间来排序。
SQL 大概是 SELECT * FROM xxx WHERE uid = 123 ORDER BY update_time。

如果用户的数据比较多，那么这个语句执行的速度还是比较慢的。后来我们做了一个比较简单的优化，就是用 uid 和 update_time 
创建一个新的索引。从数据库原理上说，在 uid 确认之后，索引内的 update_time 本身就是有序的，
所以**避免了数据库再次排序的消耗**。这样一个优化之后，**查询时间从秒级降到了数十毫秒**。

总结：在所有的排序场景中，都应该尽量利用索引来排序，这样能够有效减轻数据库的负担，加快响应速度。进一步来说，像 ORDER BY，DISTINCT 等这样的操作也可以用类似的思路。

#### 1.6.3 优化 COUNT

- 用估计值取代精确值：我的这个场景对数据的准确性不是很高，所以我用了一个奇诡的方法，即用 EXPLAIN your_sql，之后用 EXPLAIN 返回的预估行数。比如说 SELECT COUNT() FROM xxx WHERE uid= 123，就可以用 EXPLAIN SELECT * FROM xxx WHERE uid = 123 来拿到一个预估值。
- 精确值：使用 Redis 之类的NoSQL来直接记录总数。或者直接有一个额外的表来记录总数也可以。
  - 用了 Redis 来维持总数，那么就会涉及数据一致性的问题。这本质上是一个分布式事务的问题。主要思路有两个：
    - 如果数据短时间不一致但是业务可以接受的话，那么就可以考虑异步刷新 Redis 上的总数。
    - 使用 Canal 之类的工具监听 MySQL binlog，然后刷新 Redis 上的总数。

#### 1.6.4 用 WHERE 替换 HAVING

如果不是使用聚合函数来作为过滤条件，最好还是将过滤条件优先写到 WHERE 里面。

在这个案例里面因为你提到了 SQL 的执行顺序，那么面试官可能会问 **SQL 执行顺序**的问题，你需要有一个心理准备。

#### 1.6.5 优化分页中的偏移量

**优化思路就是使用小偏移量。**

在我们的系统里面，最开始有一个分页查询，那时候数据量还不大，所以一直没出什么问题。后来数据量大了之后，我们发现如果往后翻页，页码越大查询越慢。问题关键就在于我们用的 LIMIT 偏移量太大了。

所以后来我就在原本的查询语句的 WHERE 里面加上了一个 **WHERE id > max_id 的条件**。这个 max_id 就是上一批的最大 ID。这样我就可以保证 LIMIT 的偏移量永远是 0。这样修改之后，查询的速度非常稳定，一直保持在毫秒级。

总结：很多时候因为测试环境数据量太小，这种性能问题根本不会被发现。所以所有使用分页的查询都应该考虑引入类似的查询条件。

#### 1.6.6 SQL 包含 or 的优化

- 包含 or 的 SQL，如果两边的字段有一个不是索引，则一定不走索引
- 如果两边都是索引，需要进行判断，这里的判断条件，考虑因素有索引列的区分度，除此之外不知道还有没没有：
  - 若优化器判断，走索引好，就走索引
  - 若优化器判断，走索引不好，就不走索引，不走索引则使用 union 进行优化

### 1.7 面试思路总结

此外还有一点你需要注意：**花样繁多的东西，你并不需要全部掌握**。比如说有很多 SQL 优化的手段可能我都没听过。因此**在面试过程中你需要注意把控节奏，要掌握整个面试的主动权**。或者说虽然**看上去面试官还在频繁问你问题，但是他问的问题都是你心中有数的，所以实际上是你在暗中控制整个面试的过程**。

**而如果你不能控制好这种节奏，面试官就会随便问，那么问到你不知道的也毫不意外了。**


> 参考链接：
>
> [11｜SQL优化：如何发现SQL中的问题？](https://leeshengis.com/archives/674168#google_vignette "11｜SQL优化：如何发现SQL中的问题？")
> 
> [19 如何根治慢 SQL？](https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%af%b4%e9%80%8f%e6%80%a7%e8%83%bd%e6%b5%8b%e8%af%95/19%20%20%e5%a6%82%e4%bd%95%e6%a0%b9%e6%b2%bb%e6%85%a2%20SQL%ef%bc%9f.md "19 如何根治慢 SQL？")
> 
> [(十七)SQL优化篇：如何成为一位写优质SQL语句的绝顶高手！](https://juejin.cn/post/7164652941159170078 "(十七)SQL优化篇：如何成为一位写优质SQL语句的绝顶高手！")
> 
> [无效回表谁的锅？存储引擎：这事儿不赖我](https://mp.weixin.qq.com/s?__biz=Mzg5ODU2ODczMQ==&mid=2247499167&idx=1&sn=f6510663e93d0c7e5154ea6f6bde0fde&chksm=c0623aebf715b3fd057755f1062d4a2656160f2beaf890db6b8228dc11837d2bd17e26c42666&token=1429342161&lang=zh_CN#rd "无效回表谁的锅？存储引擎：这事儿不赖我")
> 
